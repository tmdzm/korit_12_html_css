# 용도에 따른 태그

ch09_applied

`<!DOCTYPE html>` : html5 형식으로 작성되었다는 것을 암시
이게 빠지면 옛날 브라우저 형태로 문서를 읽게되는데, 제대로된 출력이 안될가능성이 높다.

`<head>` : 메타데이터, 사진을 찍었을때 그 사진 자체가 아니라 찍은 시간, 위치같은 정보들, 웹사이트에서 눈으로 볼 수는 없지만 컴퓨터가 읽어낼 문서의 정보와 사양이 담겨 있다.<br>
  - `<title>` : 브라우저 상단 탭에 나타나는 사이트 제목 -> 북마크시 지정되는 이름, 검색엔진에서 나타나는 검색 결과에 표시됨
  - `<meta>` : 
    1. charset : 해당 페이지에 사용된 문자들을 어떤 방식으로 읽을지를 명시, UTF-8은 문자 인코딩 방식을 의미하기에 독립적으로 생각
    
    2. viewport : 화면에 보여지는 영역, 모바일 기준으로 사람 눈에 보이는 시각적 뷰포트의 브라우저가 웹페이지를 표시하는 영역에 해당하는 레이아웃 뷰포트가 대체로 동일

    3. Open Graph 정보
    - 메타(전 페이스북)에서 만든 프로토콜로 웹페이지의 주소를 복사해서 페이스북/카카오톡등의 sns 등의 계정으로 공유할 때 보여지는 웹사이트 제목과 썸네일 등의 기본 정보를 태그 형태로 정의하는 방식

```html
<head>
  <meta property="og:title" content="Korea IT Academy 12월 국비 과정">
  <meta property="og:description" content="심화 HTML/CSS및 기초 Java script 과정">
  <meta property="og:image" content="url">
</head>
```

와 같이 작성하게 되면 공유했을 때 썸네일로 이미지, 그리고 조금 두꺼운 폰트로 제목 / 그리고 생략 ...을 포함한 내용이 SNS에 포함되게 된다.

- favicon : 상단 탭 제목 옆에 원하는 이미지 삽입 가능

```
<link rel="shortcut icon" href="./상대경로.pn" type="image/x-icon">
```

# 시멘틱 태그
- div / span 태그만 이용해도 웹페이지를 만드는 것이 가능하지만, 어떤 용도로 사용되는지 구분하는 것이 어렵다.(그래서 옛날에는 div 태그에 class로 기능이나 용도를 하나하나 다 집어넣기도 했다.) 이부분을 해결하기 위한 개념이 시멘틱 태그

## 시멘틱 태그의 장점
- 의미있는 태그라는 의미, HTML5에서 적극적으로 활용하여 웹사이트를 구성
- 자체적으론 `<div>`랑 동일하나 역할 별로 이름이 다르게 붙여진 div라고 보면 된다.
1. 웹 접근성 개선 : 스크린리더를 활용해 웹페이지에서 필요한 정보를 빠르게 읽어준다.
2. SEO 상의 장점 : 검색엔진을 통하게 되면 검색창에서 내부 페이지 정보를 간략하게 보여준다. 이때, 검색엔진이 노출시켜 주는 부분을 의도한대로 나오게 하기가 쉽다.
3. 유지보수와 가독성에 유리 : 계속해서 변경을 해줘야 하는데, 전부 div로 되어있으면 쉽게 적을 수 있는가의 문제

## 시멘틱 태그의 종류
1. `<header>` : 페이지나 구획의 최상단에서 제목 역할
2. `<nav>` : 링크로 이동하는 요소를 포함. 페이지 내에 id로 지정된 요소로 즉시 이동가능
3. `<footer>` : 최하단에 보여지는 요소 담당
4. `<main>` : 페이지의 가장 중요한 부분으로 주요 내용이 들어가는 메인 영역에 사용. 페이지마다 반드시 한개만 존재
5. `<aside>` 메인과 어느정도 간접적으로 연관된 컨텐츠를 포함하는 데 사용
6. `<section>` : 페이지의 컨텐츠를 주제나 성격에 따라 일상 단위의 구획으로 나누는데 사용된다. 이보다 더 작은 단위로 나누기 시작한다면 그때는 `<div>`를 사용한다.
사이트 내 여러 군데에 사용 가능
7. `<article>` : 페이지 내에서 여러번 재사용되거나 페이지로부터 독립적인, 즉 다른 페이지에서도 사용될 수 있는 컨텐츠에 주로 사용된다. 주로 페이지 내의 카드 요소, 기사나 블로그 , 포스트 , 댓글

8. `<figure>` : img 태그와 그 이미지를 설명하는 figcaption 태그를 묶어 놓을때 사용

# 기타 미디어 삽입
## SVG 이미지
SVG란? Scalable Vector Graphics는 일반적인 png나 jpg 와 다른 이미지 파일.
픽셀 이미지는 확대할 수록 픽셀 단위가 커지면서 해상도가 떨어진다.
svg는 확대해도 이미지가 깨지지 않는 특징이 있다.

1. 이미지 파일 경로를 삽입하는 방법을 쓸 수 있다.
<img src="https://showcases.yalco.kr/html-css-scoop/03-05/yalco-y.svg" alt = "얄코 개발자님">

2. svg 소스를 불러오는 방법
웹 상에 올려져 있는 svg 이미지를 불러올 경우에 _이미지를 다른 이름으로 지정_을 선택해서 저장한다. 그리고
탐색기창으로 불러올 때 소스 코드 형식으로 불러오게 될 경우에

`<svg>/<style> 및 좌표 공식을 가지는 <path>` 태그로 이루어져있다.
이를 `<figure>` 태그에 넣어서 사용하는데, 크기 조절을 하는 등 추가적인 편집이 필요하다.

## 오디오와 동영상

```html
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>
<body bgcolor="5f5f5f">
  <figure>
      <figcaption>
         얄코 영상 오디오
      </figcaption>
      <audio controls src="https://showcases.yalco.kr/html-css-scoop/03-05/audio.mp3"></audio>
  </figure>
  <br>
  <figure>
      <figcaption>
        얄코 영상 비디오
      </figcaption>
      <video controls src="https://showcases.yalco.kr/html-css-scoop/03-05/video.mp4"></video>
  </figure>
</body>
</html>

```

`<audio>` 태그는 이미지 태그처럼 src 속성에 오디오 파일의 경로를 넣는다.
controls라고 하는 속성이 있는데, 제어 인터페이스에 해당하는 것으로 재생,멈춤,진행 등을 나타내는 컨트롤러를 표시한다.
controls가 없으면 페이지에 컨트롤러 자체가 뜨지 않아 미디어 재생불가

autoplay 속성은 자동 재생
loop는 반복재생

```html
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>
<body bgcolor="5f5f5f">
  <h1>02_audio_video</h1>
  <figure>
      <figcaption>
         얄코 영상 오디오
      </figcaption>
      <audio controls>
        <source src="https://showcases.yalco.kr/html-css-scoop/03-05/audio.mp3" type="audio/mpeg">
        <source src="https://showcases.yalco.kr/html-css-scoop/03-05/audio.wav" type="audio/wav">
      </audio>
  </figure>
  <br>
  <figure>
      <figcaption>
        얄코 영상 비디오
      </figcaption>
      <video controls>
        <source  src="https://showcases.yalco.kr/html-css-scoop/03-05/video.mov" type="video/quicktime">
        <source  src="https://showcases.yalco.kr/html-css-scoop/03-05/video.mp4" type="video/mp4">
        <source  src="https://showcases.yalco.kr/html-css-scoop/03-05/video.webm" type="video/webm">
      </video>
  </figure>
</body>
</html>
```

src 속성을 통해서 집어넣는 방법, 그런데 일부러 여러 예시를 저장했다. 윈도우 버전의 edge나 Mac에서는 mov를 또 지원 안한다. 그래서 브라우저 별로 다르게 지원을 하기 때문에 동일한 영상이라도 확장자마다 집어넣어야 할 때도 있다. 이상을 이유로 동일한 source를 준비해서 올린다.

브라우저에 따라서 어떤 태그나 파일 형식이 사용가능한지를 ai를 통해 미리 체크하는 것도 중요하다.

그리고 브라우저 상에서 '이 브라우저에서 오디오 태그가 지원되징 낳습니다' 문구가 우리 눈에 보이지 않는 점도 생각해 봐야한다.

이는 audio 태그나 video 태그가 아예 없는 구 버전 브라우저에서 대신 보여주는 문구에 해당한다.
img태그의 alt 같은것

## 가독성을 위한 이름 짓기

```css
article {/* "..."; */}
article.aside {/* "..."; */}
article.aside.figure {/* "..."; */}
article.div.header {/* "..."; */}
article.ul.li {/* "..."; */}
article.div.li {/* "..."; */}
```

이상과 같이 작성하면 반복이 잦다.
article하나 더 생기면 머리아픈 일이 발생할 가능성이 있다.

그래서 생겨난 방식.
## 클래스 위주로 이름짓기
시멘틱 태그만으로 이름짓는건 한계가 있다.
_각 요소 마다 클래스명을 지정하는 방식_ 을 채택하고
그 클래스명을 예쁘게 짓는것이 좋다.

```html
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
  <link rel="stylesheet" href="./03_naming.css">
</head>
<body bgcolor="5f5f5f">
  <article class="card">
    <aside class="thumb">
      <figure class="image">

      </figure>
    </aside>
    <div class="body">
      <header class="title"></header>
        <ul class="list">
          <li class="lsit-item-special"></li>
          <li class="list-item"></li>
          <li class="list-item"></li>
        </ul>
    </div>
  </article>
</body>
</html>
```
태그의 각 요소들이 무슨 역할을 하는지는 영어만 읽으면 이해가 되긴하는데, 
그 영어를 읽기 위해서 엄청 태그 요소들이 길어졌고, css 선택자는 더 길어지는 문제가 생겼다.
결국 바깥쪽 요소부터 하나씩 들어간다는 점은 똑같다.

그래서 클래스만 사용해서 작성하는 방법보다 더 명확하게 사이트 내의 요소들을 선택할 수 있고, 효율적이고 체계적인 방법이 필요해 졌다.

## BEM으로 이름 짓기
- BEM : block element modifier의 축약어로 웹사이트에 있는 요소의 일정 부분을 컴포넌트로 나눈 후 그것을 블록으로 지정하는 방식.

card 레이아웃 전체를 하나의 블록으로 보고, 같은 블록이라면 태그명 뒤에 마침표와 해당 블록명을 통일하여 붙여준다.

블록 안의 요소를 특징적인 이름으로 지은 다음 __를 입력하여 붙여주는 개발자들의 관행

BEM을 사용하게 되면 코드량이 줄어들고 요소명이 중복되는 것을 막을 수 있다.
길이가 길어지긴 한다.

경우에 따라서 이상의 세 가지 방법을 잘 섞어서 만드는것이 중요하다.

# 현대 CSS 요소 지정 방법

# 반복 및 공통되는 스타일
CSS 사용하다보면 여러 페이지에서 같은 코드를 써야할 일이 많다.
CSS에서 공통적으로 사용되는 코드를 모듈화하여 다른 CSS파일로 임포트 하는 방법을 수업할 예정.
자주 사용하는 속성값을 변수로 지정하는 방법 수업할 예정.

## 다른 CSS 파일 임포트하기

`@import url(경로)`
그런데 모듈화란? : 프로그램을 재사용가능한 단위로 더 적게 나누는 것을 의미한다.

## CSS 변수 사용하기
예를 들어 색상을 HEX로 쓰는데 매법 여섯자리를 입력하려고 하면 기억하기도 어렵고 실수도 많을것이다. 어파이 기억하는건 5f5f5f 밖에 없으니까. 이럴 때 원하는 색에 변수명을 할당할 수 있다면 훨씬 편하지 않을까?

CSS에서 변수를 나타낼 때는 원하는 변수명을 지정하고 그 앞에 --를 입력해서 변수임을 표시하는 방법이 있다.

페이지 메인 컬러라면 --color-main, 가장 작은 텍스트 크기를 지정하고 싶다면 --fron-small과 같은 방식

```css
u{
  background-color: var(--warn,lightblue);
}
```


```css
.wrong {
  --warn : yellow;
}
```

이상의 두 코드를 고려했을 때 다른 var()와 달리 var(arg1, arg2) 형태로 작성되어 있었다.
이는 사용할 수 있으면 --warn변수를 사용하고, 없을 경우에는 대안(alt)으로 lightblue를 사용하라는 의미로 작성되었다.

그리고 전혀 사용하지 않았지만 :root의 경우 최초 디자인 회의시에 작성되는 가장 기초적인 목록중 하나다. 즉 h1에는 --front-xxx-large 변수를 사용한다는 뜻이다.

색상 조합 참조 사이트 :
https://mycolor.space

# 웹 폰트 사용하기

## 구글은 webfont.com

```css
@font-face {
    font-family: 'Paperozi';
    src: url('https://cdn.jsdelivr.net/gh/projectnoonnu/2408-3@1.0/Paperlogy-1Thin.woff2') format('woff2');
    font-weight: 100;
    font-display: swap;
}

@font-face {
    font-family: 'Paperozi';
    src: url('https://cdn.jsdelivr.net/gh/projectnoonnu/2408-3@1.0/Paperlogy-2ExtraLight.woff2') format('woff2');
    font-weight: 200;
    font-display: swap;
}

@font-face {
    font-family: 'Paperozi';
    src: url('https://cdn.jsdelivr.net/gh/projectnoonnu/2408-3@1.0/Paperlogy-3Light.woff2') format('woff2');
    font-weight: 300;
    font-display: swap;
}

@font-face {
    font-family: 'Paperozi';
    src: url('https://cdn.jsdelivr.net/gh/projectnoonnu/2408-3@1.0/Paperlogy-4Regular.woff2') format('woff2');
    font-weight: 400;
    font-display: swap;
}

@font-face {
    font-family: 'Paperozi';
    src: url('https://cdn.jsdelivr.net/gh/projectnoonnu/2408-3@1.0/Paperlogy-5Medium.woff2') format('woff2');
    font-weight: 500;
    font-display: swap;
}

@font-face {
    font-family: 'Paperozi';
    src: url('https://cdn.jsdelivr.net/gh/projectnoonnu/2408-3@1.0/Paperlogy-6SemiBold.woff2') format('woff2');
    font-weight: 600;
    font-display: swap;
}

@font-face {
    font-family: 'Paperozi';
    src: url('https://cdn.jsdelivr.net/gh/projectnoonnu/2408-3@1.0/Paperlogy-7Bold.woff2') format('woff2');
    font-weight: 700;
    font-display: swap;
}

@font-face {
    font-family: 'Paperozi';
    src: url('https://cdn.jsdelivr.net/gh/projectnoonnu/2408-3@1.0/Paperlogy-8ExtraBold.woff2') format('woff2');
    font-weight: 800;
    font-display: swap;
}

@font-face {
    font-family: 'Paperozi';
    src: url('https://cdn.jsdelivr.net/gh/projectnoonnu/2408-3@1.0/Paperlogy-9Black.woff2') format('woff2');
    font-weight: 900;
    font-display: swap;
}
```

이상의 코드는 눈누에서 무료 폰트를 가져왔을 때의 부분이다. @import가 아니다.
자체 서버에서 서채도 제공하는것
`@font-face`에 font-family의 속성값이 다 동일하지만, font-weight에서의 차이가 있음을 확인할 수 있다.
